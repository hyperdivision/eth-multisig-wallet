#! /usr/bin/env node
const path = require('path')
const fs = require('fs')
const evmOpcodes = require('evm-opcodes')

const args = require('minimist')(process.argv.slice(2), {
  default: {
    h: false,
    p: true
  },
  string: [
    'contract-json',
    'source-dir',
    'trace-json'
  ],
  boolean: [
    'help',
    'pretty'
  ],
  alias: {
    c: 'contract-json',
    t: 'trace-json',
    s: 'source-dir',
    h: 'help'
  }
})

if (args.h) {
  console.error(`sourcemap to Parity trace mapper

USAGE

  sourcemap --contract=Deposit.json --source-dir=./contracts --trace=trace.json

OPTIONS

  -c, --contract-json Path to the JSON specification for the contract
  -s, --source-dir    Path to contract source directory
  -t, --trace-json    Path to JSON trace from parity_trace(tx, ['vmTrace'])
  -p, --pretty        Pretty print output
  -h, --help          Show this help message
`)
  process.exit(1)
}

const contractPath = path.resolve(args.c)
const tracePath = path.resolve(args.t)
const source = path.resolve(args.s)

const trace = require(tracePath)
const contract = require(contractPath)

if (trace.vmTrace.code !== contract.deployedBytecode) {
  console.error('Trace bytecode does not match Contract bytecode')
  process.exit(1)
}

const opcodes = new Map(evmOpcodes.map(o => [o.opcode, o]))

contract.sources = contract.sources.map(f => path.resolve(source, f))
var files = contract.sources.map(f => fs.readFileSync(f))

const isPush = inst => inst >= 0x60 && inst < 0x7f
const pushDataLength = inst => inst - 0x5f
const instructionLength = inst => (isPush(inst) ? 1 + pushDataLength(inst) : 1)

const byteToInstIndex = bytecode => {
  const result = []
  let byteIndex = 0
  let instIndex = 0
  while (byteIndex < bytecode.length) {
    const length = instructionLength(bytecode[byteIndex])
    for (let i = 0; i < length; i += 1) {
      result.push(instIndex)
    }
    byteIndex += length
    instIndex += 1
  }
  return result
}

const bytecode = Buffer.from(contract.deployedBytecode.slice(2), 'hex')
const instructionMapping = byteToInstIndex(bytecode)

const tokens = contract.deployedSourceMap.split(';')
var last = {
  offset: null,
  length: null,
  file: null,
  jump: null,
  modifierDepth: null
}

const parsed = []
for (var i = 0; i < tokens.length; i++) {
  const [s, l, f, j, m] = tokens[i].split(':')
  const next = {
    offset: Number(s || last.offset),
    length: Number(l || last.length),
    file: Number(f || last.file),
    jump: j || last.jump,
    modifierDepth: Number(m || last.modifierDepth)
  }

  parsed.push(next)

  last = next
}

const stack = []
const memory = Buffer.alloc(2 ** 16)

const sc = trace.vmTrace.ops.map(op => {
  const bytePosition = instructionMapping[op.pc]
  const sourceMapping = parsed[bytePosition]
  const instruction = opcodes.get(bytecode[op.pc])
  const instructionByteLength = instructionLength(instruction.opcode)

  if (['REVERT', 'RETURN'].include(instruction.mnemonic)) {
    const offset = Number(stack[1]) + 68
    const length = Number(stack[0])

    var message = memory.subarray(offset, offset + length - 68).toString()
  }

  const before = stack.slice()
  var plen = instruction.inputs.length
  while (plen-- >= 0) stack.pop()
  stack.push(...op.ex.push)
  const after = stack.slice()

  if (op.ex.mem) {
    memory.set(Buffer.from(op.ex.mem.data.slice(2), 'hex'), op.ex.mem.off)
  }

  if (sourceMapping == null) return { message, op, before, after, bytePosition, instruction, instructionByteLength }
  if (files[sourceMapping.file] == null) return { message, op, before, after, bytePosition, instruction, instructionByteLength, sourceMapping, file: 'Internal', source: null }

  return { message, op, bytePosition, instruction, instructionByteLength, before, after, file: contract.sources[sourceMapping.file], sourceMapping, source: files[sourceMapping.file].slice(sourceMapping.offset, sourceMapping.offset + sourceMapping.length).toString() }
})

console.log(JSON.stringify(sc, null, args.p ? 2 : 0))
